diff --git a/./config.def.h b/../dwm-p/config.def.h
index a9ac303..4935b08 100644
--- a/./config.def.h
+++ b/../dwm-p/config.def.h
@@ -1,25 +1,23 @@
 /* See LICENSE file for copyright and license details. */
 
 /* appearance */
-static const unsigned int borderpx  = 1;        /* border pixel of windows */
-static const unsigned int snap      = 32;       /* snap pixel */
-static const int showbar            = 1;        /* 0 means no bar */
-static const int topbar             = 1;        /* 0 means bottom bar */
-static const char *fonts[]          = { "monospace:size=10" };
-static const char dmenufont[]       = "monospace:size=10";
-static const char col_gray1[]       = "#222222";
-static const char col_gray2[]       = "#444444";
-static const char col_gray3[]       = "#bbbbbb";
-static const char col_gray4[]       = "#eeeeee";
-static const char col_cyan[]        = "#005577";
-static const char *colors[][3]      = {
-	/*               fg         bg         border   */
-	[SchemeNorm] = { col_gray3, col_gray1, col_gray2 },
-	[SchemeSel]  = { col_gray4, col_cyan,  col_cyan  },
-};
+static const unsigned int borderpx = 2;       /* border pixel of windows */
+static const unsigned int snap     = 32;      /* snap pixel */
+static const unsigned int minwsz   = 1;       /* minimal height of a client for smfact */
+static const unsigned int gappx    = 5;       /* gap pixel between windows */
+static const int showbar           = 1;       /* 0 means no bar */
+static const int topbar            = 1;       /* 0 means bottom bar */
+static const char *fonts[]         = { "dina:size=8", "Wuncon Siji:size=8" };
+static const char dmenufont[]      = "dina:size=8";
+
+/* colors sourced from Xresources values */
+#define NORFG "foreground"
+#define NORBG "color8"
+#define SELFG "color15"
+#define SELBG "background"
 
 /* tagging */
-static const char *tags[] = { "1", "2", "3", "4", "5", "6", "7", "8", "9" };
+static const char *tags[] = { "一", "二", "三", "四", "五", "六", "七", "八", "九" };
 
 static const Rule rules[] = {
 	/* xprop(1):
@@ -27,55 +25,111 @@ static const Rule rules[] = {
 	 *	WM_NAME(STRING) = title
 	 */
 	/* class      instance    title       tags mask     isfloating   monitor */
-	{ "Gimp",     NULL,       NULL,       0,            1,           -1 },
 	{ "Firefox",  NULL,       NULL,       1 << 8,       0,           -1 },
+	{ "Firefox",  "Places",   NULL,       0,            1,           -1 },
+	{ "Firefox",  "Browser",  NULL,       0,            1,           -1 },
+	{ "Icecat",   NULL,       NULL,       1 << 8,       0,           -1 },
+	{ "Icecat",   "Places",   NULL,       0,            1,           -1 },
+	{ "Icecat",   "Browser",  NULL,       0,            1,           -1 },
+	{ "Java",     NULL,       NULL,       0,            1,           -1 },
+	{ "Eclipse",  NULL,       NULL,       1 << 6,       0,           -1 },
+	{ "Lxappearance",NULL,    NULL,       0,            1,           -1 },
+	{ "com-intellij-rt-execution-application-AppMain",
+	              NULL,       NULL,       0,            1,           -1 },
+	{ "Quartus",  NULL,       NULL,       1 << 7,       0,           -1 },
 };
 
 /* layout(s) */
 static const float mfact     = 0.55; /* factor of master area size [0.05..0.95] */
+static const float smfact    = 0.00; /* factor of tiled clients [0.00..0.95] */
 static const int nmaster     = 1;    /* number of clients in master area */
-static const int resizehints = 1;    /* 1 means respect size hints in tiled resizals */
+static const int resizehints = 0;    /* 1 means respect size hints in tiled resizals */
 
 static const Layout layouts[] = {
-	/* symbol     arrange function */
-	{ "[]=",      tile },    /* first entry is default */
-	{ "><>",      NULL },    /* no layout function means floating behavior */
-	{ "[M]",      monocle },
+	/* symbol        arrange function */
+	{ "/振り",      tile },    /* first entry is default */
+	{ "/振り",      NULL },    /* no layout function means floating behavior */
+	{ "[M]/振り",    monocle },
+	{ "/振り",      bstack },
 };
 
 /* key definitions */
-#define MODKEY Mod1Mask
+#define MODKEY Mod4Mask
 #define TAGKEYS(KEY,TAG) \
-	{ MODKEY,                       KEY,      view,           {.ui = 1 << TAG} }, \
+	{ MODKEY,                       KEY,      comboview,      {.ui = 1 << TAG} }, \
 	{ MODKEY|ControlMask,           KEY,      toggleview,     {.ui = 1 << TAG} }, \
-	{ MODKEY|ShiftMask,             KEY,      tag,            {.ui = 1 << TAG} }, \
+	{ MODKEY|ShiftMask,             KEY,      combotag,       {.ui = 1 << TAG} }, \
 	{ MODKEY|ControlMask|ShiftMask, KEY,      toggletag,      {.ui = 1 << TAG} },
 
 /* helper for spawning shell commands in the pre dwm-5.0 fashion */
 #define SHCMD(cmd) { .v = (const char*[]){ "/bin/sh", "-c", cmd, NULL } }
 
 /* commands */
-static char dmenumon[2] = "0"; /* component of dmenucmd, manipulated in spawn() */
-static const char *dmenucmd[] = { "dmenu_run", "-m", dmenumon, "-fn", dmenufont, "-nb", col_gray1, "-nf", col_gray3, "-sb", col_cyan, "-sf", col_gray4, NULL };
-static const char *termcmd[]  = { "st", NULL };
+static char dmenumon[2] = "0";
+static const char *dmenucmd[]     = { "dmenu_run_recent.sh", NULL };
+static const char *termcmd[]      = { "urxvtc", NULL };
+static const char *nmcmd[]        = { "networkmanager_dmenu", NULL };
+static const char *lockcmd[]      = { "lockscreen.sh", NULL};
+static const char *suscmd[]       = { "systemctl", "suspend", NULL };
+static const char *mutecmd[]      = { "pulseaudio-ctl.sh", "mute", NULL };
+static const char *muteincmd[]    = { "pulseaudio-ctl.sh", "mute-input", NULL };
+static const char *volucmd[]      = { "pulseaudio-ctl.sh", "up", NULL };
+static const char *voldcmd[]      = { "pulseaudio-ctl.sh", "down", NULL };
+static const char *otogglecmd[]   = { "output-toggle.sh", NULL };
+static const char *ssucmd[]       = { "upload.sh", NULL };
+static const char *ssccmd[]       = { "upload.sh", "-c", NULL };
+static const char *brightup10[]   = { "bright.sh", "+", "10", NULL };
+static const char *brightdown10[] = { "bright.sh", "-", "10", NULL };
+static const char *brightup1[]    = { "bright.sh", "+", "1", NULL };
+static const char *brightdown1[]  = { "bright.sh", "-", "1", NULL };
+static const char *blankoff[]     = { "blank.sh", "-off", NULL };
+static const char *blankon[]      = { "blank.sh", "-on", NULL };
+static const char *pmenucmd[]     = { "passmenu", NULL };
+static const char *recompile[]    = { "redwm.sh", NULL };
+static const char *patchcolors[]  = { "recolor.sh", "--fast", NULL };
+static const char *nightcmd[]     = { "night.sh", NULL };
 
 static Key keys[] = {
 	/* modifier                     key        function        argument */
+	{ 0,                            0xff61,    spawn,          {.v = ssucmd } },
+	{ ControlMask,                  0xff61,    spawn,          {.v = ssccmd } },
+	{ 0,                            0x1008ff12,spawn,          {.v = mutecmd } },
+	{ 0,                            0x1008ffb2,spawn,          {.v = muteincmd } },
+	{ ControlMask,                  0x1008ff12,spawn,          {.v = otogglecmd } },
+	{ 0,                            0x1008ff13,spawn,          {.v = volucmd } },
+	{ 0,                            0x1008ff11,spawn,          {.v = voldcmd } },
+	{ 0,                            0x1008ff41,spawn,          {.v = lockcmd } },
+	{ 0,                            0x1008ff2d,spawn,          {.v = lockcmd } },
+	{ 0,                            0x1008ff2d,spawn,          {.v = suscmd } },
+	{ 0,                            0x1008ff02,spawn,          {.v = brightup10 } },
+	{ 0,                            0x1008ff03,spawn,          {.v = brightdown10 } },
+	{ MODKEY,                       0xff50    ,spawn,          {.v = blankoff } },
+	{ MODKEY,                       0xff57    ,spawn,          {.v = blankon } },
+	{ ControlMask,                  0x1008ff02,spawn,          {.v = brightup1 } },
+	{ ControlMask,                  0x1008ff03,spawn,          {.v = brightdown1 } },
 	{ MODKEY,                       XK_p,      spawn,          {.v = dmenucmd } },
+	{ MODKEY|ShiftMask,             XK_p,      spawn,          {.v = pmenucmd } },
 	{ MODKEY|ShiftMask,             XK_Return, spawn,          {.v = termcmd } },
+	{ MODKEY|ControlMask|ShiftMask, XK_w,      spawn,          {.v = nmcmd } },
+	{ MODKEY,                       XK_n,      spawn,          {.v = nightcmd } },
 	{ MODKEY,                       XK_b,      togglebar,      {0} },
 	{ MODKEY,                       XK_j,      focusstack,     {.i = +1 } },
 	{ MODKEY,                       XK_k,      focusstack,     {.i = -1 } },
+	{ MODKEY|ShiftMask,             XK_j,      pushdown,       {0} },
+	{ MODKEY|ShiftMask,             XK_k,      pushup,         {0} },
 	{ MODKEY,                       XK_i,      incnmaster,     {.i = +1 } },
 	{ MODKEY,                       XK_d,      incnmaster,     {.i = -1 } },
-	{ MODKEY,                       XK_h,      setmfact,       {.f = -0.05} },
-	{ MODKEY,                       XK_l,      setmfact,       {.f = +0.05} },
+	{ MODKEY|ControlMask,           XK_h,      setmfact,       {.f = -0.05} },
+	{ MODKEY|ControlMask,           XK_l,      setmfact,       {.f = +0.05} },
+	{ MODKEY|ControlMask,           XK_k,      setsmfact,       {.f = +0.05} },
+	{ MODKEY|ControlMask,           XK_j,      setsmfact,       {.f = -0.05} },
 	{ MODKEY,                       XK_Return, zoom,           {0} },
 	{ MODKEY,                       XK_Tab,    view,           {0} },
-	{ MODKEY|ShiftMask,             XK_c,      killclient,     {0} },
+	{ MODKEY,                       XK_q,      killclient,     {0} },
 	{ MODKEY,                       XK_t,      setlayout,      {.v = &layouts[0]} },
 	{ MODKEY,                       XK_f,      setlayout,      {.v = &layouts[1]} },
 	{ MODKEY,                       XK_m,      setlayout,      {.v = &layouts[2]} },
+	{ MODKEY,                       XK_u,      setlayout,      {.v = &layouts[3]} },
 	{ MODKEY,                       XK_space,  setlayout,      {0} },
 	{ MODKEY|ShiftMask,             XK_space,  togglefloating, {0} },
 	{ MODKEY,                       XK_0,      view,           {.ui = ~0 } },
@@ -93,7 +147,10 @@ static Key keys[] = {
 	TAGKEYS(                        XK_7,                      6)
 	TAGKEYS(                        XK_8,                      7)
 	TAGKEYS(                        XK_9,                      8)
-	{ MODKEY|ShiftMask,             XK_q,      quit,           {0} },
+	{ MODKEY|ShiftMask,             XK_r,      spawn,          {.v = recompile } },
+	{ MODKEY|ShiftMask,             XK_c,      quit,           {0} },
+	{ MODKEY,                       XK_r,      recolor,        {0} },
+	{ MODKEY,                       XK_r,      spawn,          {.v = patchcolors } },
 };
 
 /* button definitions */
diff --git a/./config.h b/../dwm-p/config.h
index a9ac303..4935b08 100644
--- a/./config.h
+++ b/../dwm-p/config.h
@@ -1,25 +1,23 @@
 /* See LICENSE file for copyright and license details. */
 
 /* appearance */
-static const unsigned int borderpx  = 1;        /* border pixel of windows */
-static const unsigned int snap      = 32;       /* snap pixel */
-static const int showbar            = 1;        /* 0 means no bar */
-static const int topbar             = 1;        /* 0 means bottom bar */
-static const char *fonts[]          = { "monospace:size=10" };
-static const char dmenufont[]       = "monospace:size=10";
-static const char col_gray1[]       = "#222222";
-static const char col_gray2[]       = "#444444";
-static const char col_gray3[]       = "#bbbbbb";
-static const char col_gray4[]       = "#eeeeee";
-static const char col_cyan[]        = "#005577";
-static const char *colors[][3]      = {
-	/*               fg         bg         border   */
-	[SchemeNorm] = { col_gray3, col_gray1, col_gray2 },
-	[SchemeSel]  = { col_gray4, col_cyan,  col_cyan  },
-};
+static const unsigned int borderpx = 2;       /* border pixel of windows */
+static const unsigned int snap     = 32;      /* snap pixel */
+static const unsigned int minwsz   = 1;       /* minimal height of a client for smfact */
+static const unsigned int gappx    = 5;       /* gap pixel between windows */
+static const int showbar           = 1;       /* 0 means no bar */
+static const int topbar            = 1;       /* 0 means bottom bar */
+static const char *fonts[]         = { "dina:size=8", "Wuncon Siji:size=8" };
+static const char dmenufont[]      = "dina:size=8";
+
+/* colors sourced from Xresources values */
+#define NORFG "foreground"
+#define NORBG "color8"
+#define SELFG "color15"
+#define SELBG "background"
 
 /* tagging */
-static const char *tags[] = { "1", "2", "3", "4", "5", "6", "7", "8", "9" };
+static const char *tags[] = { "一", "二", "三", "四", "五", "六", "七", "八", "九" };
 
 static const Rule rules[] = {
 	/* xprop(1):
@@ -27,55 +25,111 @@ static const Rule rules[] = {
 	 *	WM_NAME(STRING) = title
 	 */
 	/* class      instance    title       tags mask     isfloating   monitor */
-	{ "Gimp",     NULL,       NULL,       0,            1,           -1 },
 	{ "Firefox",  NULL,       NULL,       1 << 8,       0,           -1 },
+	{ "Firefox",  "Places",   NULL,       0,            1,           -1 },
+	{ "Firefox",  "Browser",  NULL,       0,            1,           -1 },
+	{ "Icecat",   NULL,       NULL,       1 << 8,       0,           -1 },
+	{ "Icecat",   "Places",   NULL,       0,            1,           -1 },
+	{ "Icecat",   "Browser",  NULL,       0,            1,           -1 },
+	{ "Java",     NULL,       NULL,       0,            1,           -1 },
+	{ "Eclipse",  NULL,       NULL,       1 << 6,       0,           -1 },
+	{ "Lxappearance",NULL,    NULL,       0,            1,           -1 },
+	{ "com-intellij-rt-execution-application-AppMain",
+	              NULL,       NULL,       0,            1,           -1 },
+	{ "Quartus",  NULL,       NULL,       1 << 7,       0,           -1 },
 };
 
 /* layout(s) */
 static const float mfact     = 0.55; /* factor of master area size [0.05..0.95] */
+static const float smfact    = 0.00; /* factor of tiled clients [0.00..0.95] */
 static const int nmaster     = 1;    /* number of clients in master area */
-static const int resizehints = 1;    /* 1 means respect size hints in tiled resizals */
+static const int resizehints = 0;    /* 1 means respect size hints in tiled resizals */
 
 static const Layout layouts[] = {
-	/* symbol     arrange function */
-	{ "[]=",      tile },    /* first entry is default */
-	{ "><>",      NULL },    /* no layout function means floating behavior */
-	{ "[M]",      monocle },
+	/* symbol        arrange function */
+	{ "/振り",      tile },    /* first entry is default */
+	{ "/振り",      NULL },    /* no layout function means floating behavior */
+	{ "[M]/振り",    monocle },
+	{ "/振り",      bstack },
 };
 
 /* key definitions */
-#define MODKEY Mod1Mask
+#define MODKEY Mod4Mask
 #define TAGKEYS(KEY,TAG) \
-	{ MODKEY,                       KEY,      view,           {.ui = 1 << TAG} }, \
+	{ MODKEY,                       KEY,      comboview,      {.ui = 1 << TAG} }, \
 	{ MODKEY|ControlMask,           KEY,      toggleview,     {.ui = 1 << TAG} }, \
-	{ MODKEY|ShiftMask,             KEY,      tag,            {.ui = 1 << TAG} }, \
+	{ MODKEY|ShiftMask,             KEY,      combotag,       {.ui = 1 << TAG} }, \
 	{ MODKEY|ControlMask|ShiftMask, KEY,      toggletag,      {.ui = 1 << TAG} },
 
 /* helper for spawning shell commands in the pre dwm-5.0 fashion */
 #define SHCMD(cmd) { .v = (const char*[]){ "/bin/sh", "-c", cmd, NULL } }
 
 /* commands */
-static char dmenumon[2] = "0"; /* component of dmenucmd, manipulated in spawn() */
-static const char *dmenucmd[] = { "dmenu_run", "-m", dmenumon, "-fn", dmenufont, "-nb", col_gray1, "-nf", col_gray3, "-sb", col_cyan, "-sf", col_gray4, NULL };
-static const char *termcmd[]  = { "st", NULL };
+static char dmenumon[2] = "0";
+static const char *dmenucmd[]     = { "dmenu_run_recent.sh", NULL };
+static const char *termcmd[]      = { "urxvtc", NULL };
+static const char *nmcmd[]        = { "networkmanager_dmenu", NULL };
+static const char *lockcmd[]      = { "lockscreen.sh", NULL};
+static const char *suscmd[]       = { "systemctl", "suspend", NULL };
+static const char *mutecmd[]      = { "pulseaudio-ctl.sh", "mute", NULL };
+static const char *muteincmd[]    = { "pulseaudio-ctl.sh", "mute-input", NULL };
+static const char *volucmd[]      = { "pulseaudio-ctl.sh", "up", NULL };
+static const char *voldcmd[]      = { "pulseaudio-ctl.sh", "down", NULL };
+static const char *otogglecmd[]   = { "output-toggle.sh", NULL };
+static const char *ssucmd[]       = { "upload.sh", NULL };
+static const char *ssccmd[]       = { "upload.sh", "-c", NULL };
+static const char *brightup10[]   = { "bright.sh", "+", "10", NULL };
+static const char *brightdown10[] = { "bright.sh", "-", "10", NULL };
+static const char *brightup1[]    = { "bright.sh", "+", "1", NULL };
+static const char *brightdown1[]  = { "bright.sh", "-", "1", NULL };
+static const char *blankoff[]     = { "blank.sh", "-off", NULL };
+static const char *blankon[]      = { "blank.sh", "-on", NULL };
+static const char *pmenucmd[]     = { "passmenu", NULL };
+static const char *recompile[]    = { "redwm.sh", NULL };
+static const char *patchcolors[]  = { "recolor.sh", "--fast", NULL };
+static const char *nightcmd[]     = { "night.sh", NULL };
 
 static Key keys[] = {
 	/* modifier                     key        function        argument */
+	{ 0,                            0xff61,    spawn,          {.v = ssucmd } },
+	{ ControlMask,                  0xff61,    spawn,          {.v = ssccmd } },
+	{ 0,                            0x1008ff12,spawn,          {.v = mutecmd } },
+	{ 0,                            0x1008ffb2,spawn,          {.v = muteincmd } },
+	{ ControlMask,                  0x1008ff12,spawn,          {.v = otogglecmd } },
+	{ 0,                            0x1008ff13,spawn,          {.v = volucmd } },
+	{ 0,                            0x1008ff11,spawn,          {.v = voldcmd } },
+	{ 0,                            0x1008ff41,spawn,          {.v = lockcmd } },
+	{ 0,                            0x1008ff2d,spawn,          {.v = lockcmd } },
+	{ 0,                            0x1008ff2d,spawn,          {.v = suscmd } },
+	{ 0,                            0x1008ff02,spawn,          {.v = brightup10 } },
+	{ 0,                            0x1008ff03,spawn,          {.v = brightdown10 } },
+	{ MODKEY,                       0xff50    ,spawn,          {.v = blankoff } },
+	{ MODKEY,                       0xff57    ,spawn,          {.v = blankon } },
+	{ ControlMask,                  0x1008ff02,spawn,          {.v = brightup1 } },
+	{ ControlMask,                  0x1008ff03,spawn,          {.v = brightdown1 } },
 	{ MODKEY,                       XK_p,      spawn,          {.v = dmenucmd } },
+	{ MODKEY|ShiftMask,             XK_p,      spawn,          {.v = pmenucmd } },
 	{ MODKEY|ShiftMask,             XK_Return, spawn,          {.v = termcmd } },
+	{ MODKEY|ControlMask|ShiftMask, XK_w,      spawn,          {.v = nmcmd } },
+	{ MODKEY,                       XK_n,      spawn,          {.v = nightcmd } },
 	{ MODKEY,                       XK_b,      togglebar,      {0} },
 	{ MODKEY,                       XK_j,      focusstack,     {.i = +1 } },
 	{ MODKEY,                       XK_k,      focusstack,     {.i = -1 } },
+	{ MODKEY|ShiftMask,             XK_j,      pushdown,       {0} },
+	{ MODKEY|ShiftMask,             XK_k,      pushup,         {0} },
 	{ MODKEY,                       XK_i,      incnmaster,     {.i = +1 } },
 	{ MODKEY,                       XK_d,      incnmaster,     {.i = -1 } },
-	{ MODKEY,                       XK_h,      setmfact,       {.f = -0.05} },
-	{ MODKEY,                       XK_l,      setmfact,       {.f = +0.05} },
+	{ MODKEY|ControlMask,           XK_h,      setmfact,       {.f = -0.05} },
+	{ MODKEY|ControlMask,           XK_l,      setmfact,       {.f = +0.05} },
+	{ MODKEY|ControlMask,           XK_k,      setsmfact,       {.f = +0.05} },
+	{ MODKEY|ControlMask,           XK_j,      setsmfact,       {.f = -0.05} },
 	{ MODKEY,                       XK_Return, zoom,           {0} },
 	{ MODKEY,                       XK_Tab,    view,           {0} },
-	{ MODKEY|ShiftMask,             XK_c,      killclient,     {0} },
+	{ MODKEY,                       XK_q,      killclient,     {0} },
 	{ MODKEY,                       XK_t,      setlayout,      {.v = &layouts[0]} },
 	{ MODKEY,                       XK_f,      setlayout,      {.v = &layouts[1]} },
 	{ MODKEY,                       XK_m,      setlayout,      {.v = &layouts[2]} },
+	{ MODKEY,                       XK_u,      setlayout,      {.v = &layouts[3]} },
 	{ MODKEY,                       XK_space,  setlayout,      {0} },
 	{ MODKEY|ShiftMask,             XK_space,  togglefloating, {0} },
 	{ MODKEY,                       XK_0,      view,           {.ui = ~0 } },
@@ -93,7 +147,10 @@ static Key keys[] = {
 	TAGKEYS(                        XK_7,                      6)
 	TAGKEYS(                        XK_8,                      7)
 	TAGKEYS(                        XK_9,                      8)
-	{ MODKEY|ShiftMask,             XK_q,      quit,           {0} },
+	{ MODKEY|ShiftMask,             XK_r,      spawn,          {.v = recompile } },
+	{ MODKEY|ShiftMask,             XK_c,      quit,           {0} },
+	{ MODKEY,                       XK_r,      recolor,        {0} },
+	{ MODKEY,                       XK_r,      spawn,          {.v = patchcolors } },
 };
 
 /* button definitions */
diff --git a/./drw.c b/../dwm-p/drw.c
index 319eb6b..c29eef6 100644
--- a/./drw.c
+++ b/../dwm-p/drw.c
@@ -63,8 +63,9 @@ utf8decode(const char *c, long *u, size_t clen)
 Drw *
 drw_create(Display *dpy, int screen, Window root, unsigned int w, unsigned int h)
 {
-	Drw *drw = ecalloc(1, sizeof(Drw));
+	Drw *drw;
 
+	drw = ecalloc(1, sizeof(Drw));
 	drw->dpy = dpy;
 	drw->screen = screen;
 	drw->root = root;
@@ -72,6 +73,7 @@ drw_create(Display *dpy, int screen, Window root, unsigned int w, unsigned int h
 	drw->h = h;
 	drw->drawable = XCreatePixmap(dpy, root, w, h, DefaultDepth(dpy, screen));
 	drw->gc = XCreateGC(dpy, root, 0, NULL);
+	drw->fontcount = 0;
 	XSetLineAttributes(dpy, drw->gc, 1, LineSolid, CapButt, JoinMiter);
 
 	return drw;
@@ -80,9 +82,6 @@ drw_create(Display *dpy, int screen, Window root, unsigned int w, unsigned int h
 void
 drw_resize(Drw *drw, unsigned int w, unsigned int h)
 {
-	if (!drw)
-		return;
-
 	drw->w = w;
 	drw->h = h;
 	if (drw->drawable)
@@ -93,39 +92,44 @@ drw_resize(Drw *drw, unsigned int w, unsigned int h)
 void
 drw_free(Drw *drw)
 {
+	size_t i;
+
+	for (i = 0; i < drw->fontcount; i++)
+		drw_font_free(drw->fonts[i]);
 	XFreePixmap(drw->dpy, drw->drawable);
 	XFreeGC(drw->dpy, drw->gc);
 	free(drw);
 }
 
 /* This function is an implementation detail. Library users should use
- * drw_fontset_create instead.
+ * drw_font_create instead.
  */
 static Fnt *
-xfont_create(Drw *drw, const char *fontname, FcPattern *fontpattern)
+drw_font_xcreate(Drw *drw, const char *fontname, FcPattern *fontpattern)
 {
 	Fnt *font;
 	XftFont *xfont = NULL;
 	FcPattern *pattern = NULL;
 
 	if (fontname) {
-		/* Using the pattern found at font->xfont->pattern does not yield the
-		 * same substitution results as using the pattern returned by
+		/* Using the pattern found at font->xfont->pattern does not yield same
+		 * the same substitution results as using the pattern returned by
 		 * FcNameParse; using the latter results in the desired fallback
-		 * behaviour whereas the former just results in missing-character
-		 * rectangles being drawn, at least with some fonts. */
+		 * behaviour whereas the former just results in
+		 * missing-character-rectangles being drawn, at least with some fonts.
+		 */
 		if (!(xfont = XftFontOpenName(drw->dpy, drw->screen, fontname))) {
-			fprintf(stderr, "error, cannot load font from name: '%s'\n", fontname);
+			fprintf(stderr, "error, cannot load font: '%s'\n", fontname);
 			return NULL;
 		}
 		if (!(pattern = FcNameParse((FcChar8 *) fontname))) {
-			fprintf(stderr, "error, cannot parse font name to pattern: '%s'\n", fontname);
+			fprintf(stderr, "error, cannot load font: '%s'\n", fontname);
 			XftFontClose(drw->dpy, xfont);
 			return NULL;
 		}
 	} else if (fontpattern) {
 		if (!(xfont = XftFontOpenPattern(drw->dpy, fontpattern))) {
-			fprintf(stderr, "error, cannot load font from pattern.\n");
+			fprintf(stderr, "error, cannot load font pattern.\n");
 			return NULL;
 		}
 	} else {
@@ -135,115 +139,157 @@ xfont_create(Drw *drw, const char *fontname, FcPattern *fontpattern)
 	font = ecalloc(1, sizeof(Fnt));
 	font->xfont = xfont;
 	font->pattern = pattern;
-	font->h = xfont->ascent + xfont->descent;
+	font->ascent = xfont->ascent;
+	font->descent = xfont->descent;
+	font->h = font->ascent + font->descent;
 	font->dpy = drw->dpy;
 
 	return font;
 }
 
-static void
-xfont_free(Fnt *font)
+Fnt*
+drw_font_create(Drw *drw, const char *fontname)
 {
-	if (!font)
-		return;
-	if (font->pattern)
-		FcPatternDestroy(font->pattern);
-	XftFontClose(font->dpy, font->xfont);
-	free(font);
+	return drw_font_xcreate(drw, fontname, NULL);
 }
 
-Fnt*
-drw_fontset_create(Drw* drw, const char *fonts[], size_t fontcount)
+void
+drw_load_fonts(Drw* drw, const char *fonts[], size_t fontcount)
 {
-	Fnt *cur, *ret = NULL;
 	size_t i;
+	Fnt *font;
 
-	if (!drw || !fonts)
-		return NULL;
-
-	for (i = 1; i <= fontcount; i++) {
-		if ((cur = xfont_create(drw, fonts[fontcount - i], NULL))) {
-			cur->next = ret;
-			ret = cur;
+	for (i = 0; i < fontcount; i++) {
+		if (drw->fontcount >= DRW_FONT_CACHE_SIZE) {
+			die("font cache exhausted.\n");
+		} else if ((font = drw_font_xcreate(drw, fonts[i], NULL))) {
+			drw->fonts[drw->fontcount++] = font;
 		}
 	}
-	return (drw->fonts = ret);
 }
 
 void
-drw_fontset_free(Fnt *font)
+drw_font_free(Fnt *font)
 {
-	if (font) {
-		drw_fontset_free(font->next);
-		xfont_free(font);
-	}
+	if (!font)
+		return;
+	if (font->pattern)
+		FcPatternDestroy(font->pattern);
+	XftFontClose(font->dpy, font->xfont);
+	free(font);
 }
 
-void
-drw_clr_create(Drw *drw, XftColor *dest, const char *clrname)
+Clr *
+drw_clr_create(Drw *drw, const char *clrname)
 {
-	if (!drw || !dest || !clrname)
-		return;
+	Clr *clr;
 
+	clr = ecalloc(1, sizeof(Clr));
 	if (!XftColorAllocName(drw->dpy, DefaultVisual(drw->dpy, drw->screen),
 	                       DefaultColormap(drw->dpy, drw->screen),
-	                       clrname, dest))
+	                       clrname, &clr->rgb))
 		die("error, cannot allocate color '%s'", clrname);
+	clr->pix = clr->rgb.pixel;
+
+	return clr;
 }
 
-/* Wrapper to create color schemes. The caller has to call free(3) on the
- * returned color scheme when done using it. */
-Scm
-drw_scm_create(Drw *drw, const char *clrnames[], size_t clrcount)
+void
+drw_clr_free(Clr *clr)
 {
-	size_t i;
-	Scm ret;
-
-	/* need at least two colors for a scheme */
-	if (!drw || !clrnames || clrcount < 2 || !(ret = ecalloc(clrcount, sizeof(XftColor))))
-		return NULL;
-
-	for (i = 0; i < clrcount; i++)
-		drw_clr_create(drw, &ret[i], clrnames[i]);
-	return ret;
+	free(clr);
 }
 
 void
-drw_setfontset(Drw *drw, Fnt *set)
+drw_setscheme(Drw *drw, ClrScheme *scheme)
+{
+	drw->scheme = scheme;
+}
+
+int
+drw_get_width(Drw *drw, int numcolors, const char *text)
 {
-	if (drw)
-		drw->fonts = set;
+	int i;
+	Fnt *curfont = drw->fonts[0];
+	int w = drw_text(drw, 0, 0, 0, 0, text, 0) + curfont->h;
+
+	for (i = 0; i < strlen(text); i++) {
+		if (text[i] > 0 && text[i] <= numcolors) {
+			/* we found a color code
+			 * drw_text counted it as a normal character and added one character's width
+			 * we aren't going to render this character, so we remove one character's width */
+			w -= curfont->xfont->max_advance_width;
+
+			if (i == 0 || i + 1 == strlen(text)) {
+				/* we're on the first or the last character of the string
+				 * drw_text already added one character's height (divided by 2) as padding to the beginning and end
+				 * we don't want to double this padding, so we skip this character */
+				continue;
+			}
+
+			if (text[i - 1] > 0 && text[i - 1] <= numcolors) {
+				/* the previous character was also a color code
+				 * we already added padding in the previous iteration
+				 * we don't want to double this padding, so we skip this character */
+				continue;
+			}
+
+			/* we are somewhere in the middle of the string and the color has changed
+			 * we want to add one character's height (divided by 2) as padding to the end of the previous colored text
+			 * and to the beginning of the new colored text */
+			 w += curfont->h;
+		}
+	}
+
+  return w;
 }
 
 void
-drw_setscheme(Drw *drw, Scm scm)
+drw_colored_text(Drw *drw, ClrScheme *scheme, int numcolors, int x, int y, unsigned int w, unsigned int h, char *text)
 {
-	if (drw)
-		drw->scheme = scm;
+	if (!drw || !drw->fontcount || !drw->scheme)
+		return;
+
+	char *buf = text, *ptr = buf, c = 1;
+	int i;
+
+	while (*ptr) {
+		for (i = 0; *ptr < 0 || *ptr > numcolors; i++, ptr++);
+		if (!*ptr)
+			break;
+		c = *ptr;
+		*ptr = 0;
+		if (i)
+			x = drw_text(drw, x, y, w, h, buf, 0) + drw->fonts[0]->h;
+		*ptr = c;
+		drw_setscheme(drw, &scheme[c-1]);
+		buf = ++ptr;
+	}
+	drw_text(drw, x-1, y, w, h, buf, 0);
 }
 
 void
-drw_rect(Drw *drw, int x, int y, unsigned int w, unsigned int h, int filled, int invert)
+drw_rect(Drw *drw, int x, int y, unsigned int w, unsigned int h, int filled, int empty, int invert)
 {
-	if (!drw || !drw->scheme)
+	if (!drw->scheme)
 		return;
-	XSetForeground(drw->dpy, drw->gc, invert ? drw->scheme[ColBg].pixel : drw->scheme[ColFg].pixel);
+	XSetForeground(drw->dpy, drw->gc, invert ? drw->scheme->bg->pix : drw->scheme->fg->pix);
 	if (filled)
-		XFillRectangle(drw->dpy, drw->drawable, drw->gc, x, y, w, h);
-	else
-		XDrawRectangle(drw->dpy, drw->drawable, drw->gc, x, y, w - 1, h - 1);
+		XFillRectangle(drw->dpy, drw->drawable, drw->gc, x, y, w + 1, h + 1);
+	else if (empty)
+		XDrawRectangle(drw->dpy, drw->drawable, drw->gc, x, y, w, h);
 }
 
 int
-drw_text(Drw *drw, int x, int y, unsigned int w, unsigned int h, unsigned int lpad, const char *text, int invert)
+drw_text(Drw *drw, int x, int y, unsigned int w, unsigned int h, const char *text, int invert)
 {
 	char buf[1024];
-	int ty;
-	unsigned int ew;
+	int tx, ty, th;
+	Extnts tex;
 	XftDraw *d = NULL;
-	Fnt *usedfont, *curfont, *nextfont;
+	Fnt *curfont, *nextfont;
 	size_t i, len;
-	int utf8strlen, utf8charlen, render = x || y || w || h;
+	int utf8strlen, utf8charlen, render;
 	long utf8codepoint = 0;
 	const char *utf8str;
 	FcCharSet *fccharset;
@@ -252,67 +298,66 @@ drw_text(Drw *drw, int x, int y, unsigned int w, unsigned int h, unsigned int lp
 	XftResult result;
 	int charexists = 0;
 
-	if (!drw || (render && !drw->scheme) || !text || !drw->fonts)
+	if (!drw->scheme || !drw->fontcount)
 		return 0;
 
-	if (!render) {
+	if (!(render = x || y || w || h)) {
 		w = ~w;
 	} else {
-		XSetForeground(drw->dpy, drw->gc, drw->scheme[invert ? ColFg : ColBg].pixel);
+		XSetForeground(drw->dpy, drw->gc, invert ?
+		               drw->scheme->fg->pix : drw->scheme->bg->pix);
 		XFillRectangle(drw->dpy, drw->drawable, drw->gc, x, y, w, h);
 		d = XftDrawCreate(drw->dpy, drw->drawable,
 		                  DefaultVisual(drw->dpy, drw->screen),
 		                  DefaultColormap(drw->dpy, drw->screen));
-		x += lpad;
-		w -= lpad;
 	}
 
-	usedfont = drw->fonts;
+	curfont = drw->fonts[0];
 	while (1) {
 		utf8strlen = 0;
 		utf8str = text;
 		nextfont = NULL;
 		while (*text) {
 			utf8charlen = utf8decode(text, &utf8codepoint, UTF_SIZ);
-			for (curfont = drw->fonts; curfont; curfont = curfont->next) {
-				charexists = charexists || XftCharExists(drw->dpy, curfont->xfont, utf8codepoint);
+			for (i = 0; i < drw->fontcount; i++) {
+				charexists = charexists || XftCharExists(drw->dpy, drw->fonts[i]->xfont, utf8codepoint);
 				if (charexists) {
-					if (curfont == usedfont) {
+					if (drw->fonts[i] == curfont) {
 						utf8strlen += utf8charlen;
 						text += utf8charlen;
 					} else {
-						nextfont = curfont;
+						nextfont = drw->fonts[i];
 					}
 					break;
 				}
 			}
 
-			if (!charexists || nextfont)
+			if (!charexists || (nextfont && nextfont != curfont))
 				break;
 			else
 				charexists = 0;
 		}
 
 		if (utf8strlen) {
-			drw_font_getexts(usedfont, utf8str, utf8strlen, &ew, NULL);
+			drw_font_getexts(curfont, utf8str, utf8strlen, &tex);
 			/* shorten text if necessary */
-			for (len = MIN(utf8strlen, sizeof(buf) - 1); len && ew > w; len--)
-				drw_font_getexts(usedfont, utf8str, len, &ew, NULL);
+			for (len = MIN(utf8strlen, (sizeof buf) - 1); len && (tex.w > w - drw->fonts[0]->h || w < drw->fonts[0]->h); len--)
+				drw_font_getexts(curfont, utf8str, len, &tex);
 
 			if (len) {
 				memcpy(buf, utf8str, len);
 				buf[len] = '\0';
 				if (len < utf8strlen)
-					for (i = len; i && i > len - 3; buf[--i] = '.')
-						; /* NOP */
+					for (i = len; i && i > len - 3; buf[--i] = '.');
 
 				if (render) {
-					ty = y + (h - usedfont->h) / 2 + usedfont->xfont->ascent;
-					XftDrawStringUtf8(d, &drw->scheme[invert ? ColBg : ColFg],
-					                  usedfont->xfont, x, ty, (XftChar8 *)buf, len);
+					th = curfont->ascent + curfont->descent;
+					ty = y + (h / 2) - (th / 2) + curfont->ascent;
+					tx = x + (h / 2);
+					XftDrawStringUtf8(d, invert ? &drw->scheme->bg->rgb : &drw->scheme->fg->rgb, curfont->xfont, tx, ty, (XftChar8 *)buf, len);
 				}
-				x += ew;
-				w -= ew;
+				x += tex.w;
+				w -= tex.w;
 			}
 		}
 
@@ -320,21 +365,26 @@ drw_text(Drw *drw, int x, int y, unsigned int w, unsigned int h, unsigned int lp
 			break;
 		} else if (nextfont) {
 			charexists = 0;
-			usedfont = nextfont;
+			curfont = nextfont;
 		} else {
 			/* Regardless of whether or not a fallback font is found, the
-			 * character must be drawn. */
+			 * character must be drawn.
+			 */
 			charexists = 1;
 
+			if (drw->fontcount >= DRW_FONT_CACHE_SIZE)
+				continue;
+
 			fccharset = FcCharSetCreate();
 			FcCharSetAddChar(fccharset, utf8codepoint);
 
-			if (!drw->fonts->pattern) {
-				/* Refer to the comment in xfont_create for more information. */
+			if (!drw->fonts[0]->pattern) {
+				/* Refer to the comment in drw_font_xcreate for more
+				 * information. */
 				die("the first font in the cache must be loaded from a font string.");
 			}
 
-			fcpattern = FcPatternDuplicate(drw->fonts->pattern);
+			fcpattern = FcPatternDuplicate(drw->fonts[0]->pattern);
 			FcPatternAddCharSet(fcpattern, FC_CHARSET, fccharset);
 			FcPatternAddBool(fcpattern, FC_SCALABLE, FcTrue);
 
@@ -346,14 +396,12 @@ drw_text(Drw *drw, int x, int y, unsigned int w, unsigned int h, unsigned int lp
 			FcPatternDestroy(fcpattern);
 
 			if (match) {
-				usedfont = xfont_create(drw, NULL, match);
-				if (usedfont && XftCharExists(drw->dpy, usedfont->xfont, utf8codepoint)) {
-					for (curfont = drw->fonts; curfont->next; curfont = curfont->next)
-						; /* NOP */
-					curfont->next = usedfont;
+				curfont = drw_font_xcreate(drw, NULL, match);
+				if (curfont && XftCharExists(drw->dpy, curfont->xfont, utf8codepoint)) {
+					drw->fonts[drw->fontcount++] = curfont;
 				} else {
-					xfont_free(usedfont);
-					usedfont = drw->fonts;
+					drw_font_free(curfont);
+					curfont = drw->fonts[0];
 				}
 			}
 		}
@@ -361,40 +409,34 @@ drw_text(Drw *drw, int x, int y, unsigned int w, unsigned int h, unsigned int lp
 	if (d)
 		XftDrawDestroy(d);
 
-	return x + (render ? w : 0);
+	return x;
 }
 
 void
 drw_map(Drw *drw, Window win, int x, int y, unsigned int w, unsigned int h)
 {
-	if (!drw)
-		return;
-
 	XCopyArea(drw->dpy, drw->drawable, win, drw->gc, x, y, w, h, x, y);
 	XSync(drw->dpy, False);
 }
 
-unsigned int
-drw_fontset_getwidth(Drw *drw, const char *text)
+void
+drw_font_getexts(Fnt *font, const char *text, unsigned int len, Extnts *tex)
 {
-	if (!drw || !drw->fonts || !text)
-		return 0;
-	return drw_text(drw, 0, 0, 0, 0, 0, text, 0);
+	XGlyphInfo ext;
+
+	XftTextExtentsUtf8(font->dpy, font->xfont, (XftChar8 *)text, len, &ext);
+	tex->h = font->h;
+	tex->w = ext.xOff;
 }
 
-void
-drw_font_getexts(Fnt *font, const char *text, unsigned int len, unsigned int *w, unsigned int *h)
+unsigned int
+drw_font_getexts_width(Fnt *font, const char *text, unsigned int len)
 {
-	XGlyphInfo ext;
+	Extnts tex;
 
-	if (!font || !text)
-		return;
+	drw_font_getexts(font, text, len, &tex);
 
-	XftTextExtentsUtf8(font->dpy, font->xfont, (XftChar8 *)text, len, &ext);
-	if (w)
-		*w = ext.xOff;
-	if (h)
-		*h = font->h;
+	return tex.w;
 }
 
 Cur *
@@ -402,9 +444,7 @@ drw_cur_create(Drw *drw, int shape)
 {
 	Cur *cur;
 
-	if (!drw || !(cur = ecalloc(1, sizeof(Cur))))
-		return NULL;
-
+	cur = ecalloc(1, sizeof(Cur));
 	cur->cursor = XCreateFontCursor(drw->dpy, shape);
 
 	return cur;
@@ -415,7 +455,6 @@ drw_cur_free(Drw *drw, Cur *cursor)
 {
 	if (!cursor)
 		return;
-
 	XFreeCursor(drw->dpy, cursor->cursor);
 	free(cursor);
 }
diff --git a/./drw.h b/../dwm-p/drw.h
index ff4355b..c51f6cd 100644
--- a/./drw.h
+++ b/../dwm-p/drw.h
@@ -1,19 +1,29 @@
 /* See LICENSE file for copyright and license details. */
+#define DRW_FONT_CACHE_SIZE 32
+
+typedef struct {
+	unsigned long pix;
+	XftColor rgb;
+} Clr;
 
 typedef struct {
 	Cursor cursor;
 } Cur;
 
-typedef struct Fnt {
+typedef struct {
 	Display *dpy;
+	int ascent;
+	int descent;
 	unsigned int h;
 	XftFont *xfont;
 	FcPattern *pattern;
-	struct Fnt *next;
 } Fnt;
 
-enum { ColFg, ColBg, ColCount }; /* Scm index */
-typedef XftColor *Scm;
+typedef struct {
+	Clr *fg;
+	Clr *bg;
+	Clr *border;
+} ClrScheme;
 
 typedef struct {
 	unsigned int w, h;
@@ -22,36 +32,45 @@ typedef struct {
 	Window root;
 	Drawable drawable;
 	GC gc;
-	Scm scheme;
-	Fnt *fonts;
+	ClrScheme *scheme;
+	size_t fontcount;
+	Fnt *fonts[DRW_FONT_CACHE_SIZE];
 } Drw;
 
+typedef struct {
+	unsigned int w;
+	unsigned int h;
+} Extnts;
+
 /* Drawable abstraction */
-Drw *drw_create(Display *dpy, int screen, Window win, unsigned int w, unsigned int h);
-void drw_resize(Drw *drw, unsigned int w, unsigned int h);
-void drw_free(Drw *drw);
+Drw *drw_create(Display *, int, Window, unsigned int, unsigned int);
+void drw_resize(Drw *, unsigned int, unsigned int);
+void drw_free(Drw *);
 
 /* Fnt abstraction */
-Fnt *drw_fontset_create(Drw* drw, const char *fonts[], size_t fontcount);
-void drw_fontset_free(Fnt* set);
-unsigned int drw_fontset_getwidth(Drw *drw, const char *text);
-void drw_font_getexts(Fnt *font, const char *text, unsigned int len, unsigned int *w, unsigned int *h);
+Fnt *drw_font_create(Drw *, const char *);
+void drw_load_fonts(Drw *, const char *[], size_t);
+void drw_font_free(Fnt *);
+void drw_font_getexts(Fnt *, const char *, unsigned int, Extnts *);
+unsigned int drw_font_getexts_width(Fnt *, const char *, unsigned int);
 
-/* Colorscheme abstraction */
-void drw_clr_create(Drw *drw, XftColor *dest, const char *clrname);
-Scm drw_scm_create(Drw *drw, const char *clrnames[], size_t clrcount);
+/* Colour abstraction */
+Clr *drw_clr_create(Drw *, const char *);
+void drw_clr_free(Clr *);
 
 /* Cursor abstraction */
-Cur *drw_cur_create(Drw *drw, int shape);
-void drw_cur_free(Drw *drw, Cur *cursor);
+Cur *drw_cur_create(Drw *, int);
+void drw_cur_free(Drw *, Cur *);
 
 /* Drawing context manipulation */
-void drw_setfontset(Drw *drw, Fnt *set);
-void drw_setscheme(Drw *drw, Scm scm);
+void drw_setfont(Drw *, Fnt *);
+void drw_setscheme(Drw *, ClrScheme *);
 
 /* Drawing functions */
-void drw_rect(Drw *drw, int x, int y, unsigned int w, unsigned int h, int filled, int invert);
-int drw_text(Drw *drw, int x, int y, unsigned int w, unsigned int h, unsigned int lpad, const char *text, int invert);
+int drw_get_width(Drw *, int, const char *);
+void drw_colored_text(Drw *, ClrScheme *, int, int, int, unsigned int, unsigned int, char *);
+void drw_rect(Drw *, int, int, unsigned int, unsigned int, int, int, int);
+int drw_text(Drw *, int, int, unsigned int, unsigned int, const char *, int);
 
 /* Map functions */
-void drw_map(Drw *drw, Window win, int x, int y, unsigned int w, unsigned int h);
+void drw_map(Drw *, Window, int, int, unsigned int, unsigned int);
diff --git a/./drw.o b/../dwm-p/drw.o
index 82aa3ce..ab722f4 100644
Binary files a/./drw.o and b/../dwm-p/drw.o differ
diff --git a/./dwm b/../dwm-p/dwm
index a97cd75..c90b193 100755
Binary files a/./dwm and b/../dwm-p/dwm differ
diff --git a/./dwm.c b/../dwm-p/dwm.c
index a5ce993..af32a03 100644
--- a/./dwm.c
+++ b/../dwm-p/dwm.c
@@ -49,18 +49,19 @@
 #define CLEANMASK(mask)         (mask & ~(numlockmask|LockMask) & (ShiftMask|ControlMask|Mod1Mask|Mod2Mask|Mod3Mask|Mod4Mask|Mod5Mask))
 #define INTERSECT(x,y,w,h,m)    (MAX(0, MIN((x)+(w),(m)->wx+(m)->ww) - MAX((x),(m)->wx)) \
                                * MAX(0, MIN((y)+(h),(m)->wy+(m)->wh) - MAX((y),(m)->wy)))
-#define ISVISIBLE(C)            ((C->tags & C->mon->tagset[C->mon->seltags]))
+#define ISVISIBLE(C)            (C->tags & C->mon->tagset[C->mon->seltags])
 #define LENGTH(X)               (sizeof X / sizeof X[0])
+#define MAXCOLORS               9
+#define NUMCOLORS               2
 #define MOUSEMASK               (BUTTONMASK|PointerMotionMask)
-#define WIDTH(X)                ((X)->w + 2 * (X)->bw)
-#define HEIGHT(X)               ((X)->h + 2 * (X)->bw)
+#define WIDTH(X)                ((X)->w + 2 * (X)->bw + gappx)
+#define HEIGHT(X)               ((X)->h + 2 * (X)->bw + gappx)
 #define TAGMASK                 ((1 << LENGTH(tags)) - 1)
-#define TEXTW(X)                (drw_fontset_getwidth(drw, (X)) + lrpad)
-#define ColBorder               2
+#define TEXTW(X)                (drw_text(drw, 0, 0, 0, 0, (X), 0) + drw->fonts[0]->h)
 
 /* enums */
 enum { CurNormal, CurResize, CurMove, CurLast }; /* cursor */
-enum { SchemeNorm, SchemeSel }; /* color schemes */
+enum { SchemeNorm, SchemeSel, SchemeLast }; /* color schemes */
 enum { NetSupported, NetWMName, NetWMState, NetWMCheck,
        NetWMFullscreen, NetActiveWindow, NetWMWindowType,
        NetWMWindowTypeDialog, NetClientList, NetLast }; /* EWMH atoms */
@@ -72,6 +73,7 @@ typedef union {
 	int i;
 	unsigned int ui;
 	float f;
+	float sf;
 	const void *v;
 } Arg;
 
@@ -112,9 +114,11 @@ typedef struct {
 	void (*arrange)(Monitor *);
 } Layout;
 
+typedef struct Pertag Pertag;
 struct Monitor {
 	char ltsymbol[16];
 	float mfact;
+    float smfact;
 	int nmaster;
 	int num;
 	int by;               /* bar geometry */
@@ -131,6 +135,7 @@ struct Monitor {
 	Monitor *next;
 	Window barwin;
 	const Layout *lt[2];
+	Pertag *pertag;
 };
 
 typedef struct {
@@ -186,9 +191,13 @@ static void motionnotify(XEvent *e);
 static void movemouse(const Arg *arg);
 static Client *nexttiled(Client *c);
 static void pop(Client *);
+static Client *prevtiled(Client *c);
 static void propertynotify(XEvent *e);
+static void pushdown(const Arg *arg);
+static void pushup(const Arg *arg);
 static void quit(const Arg *arg);
 static Monitor *recttomon(int x, int y, int w, int h);
+static void recolor(const Arg *arg);
 static void resize(Client *c, int x, int y, int w, int h, int interact);
 static void resizeclient(Client *c, int x, int y, int w, int h);
 static void resizemouse(const Arg *arg);
@@ -202,6 +211,7 @@ static void setfocus(Client *c);
 static void setfullscreen(Client *c, int fullscreen);
 static void setlayout(const Arg *arg);
 static void setmfact(const Arg *arg);
+static void setsmfact(const Arg *arg);
 static void setup(void);
 static void seturgent(Client *c, int urg);
 static void showhide(Client *c);
@@ -234,18 +244,25 @@ static int xerror(Display *dpy, XErrorEvent *ee);
 static int xerrordummy(Display *dpy, XErrorEvent *ee);
 static int xerrorstart(Display *dpy, XErrorEvent *ee);
 static void zoom(const Arg *arg);
+static void bstack(Monitor *m);
+
+static void keyrelease(XEvent *e);
+static void combotag(const Arg *arg);
+static void comboview(const Arg *arg);
+
 
 /* variables */
+char colors[NUMCOLORS][MAXCOLORS][8] = { { "", "", "" }, { "", "", "" } };
 static const char broken[] = "broken";
 static char stext[256];
 static int screen;
 static int sw, sh;           /* X display screen geometry width, height */
 static int bh, blw = 0;      /* bar geometry */
-static int lrpad;            /* sum of left and right padding for text */
 static int (*xerrorxlib)(Display *, XErrorEvent *);
 static unsigned int numlockmask = 0;
 static void (*handler[LASTEvent]) (XEvent *) = {
 	[ButtonPress] = buttonpress,
+	[ButtonRelease] = keyrelease,
 	[ClientMessage] = clientmessage,
 	[ConfigureRequest] = configurerequest,
 	[ConfigureNotify] = configurenotify,
@@ -253,6 +270,7 @@ static void (*handler[LASTEvent]) (XEvent *) = {
 	[EnterNotify] = enternotify,
 	[Expose] = expose,
 	[FocusIn] = focusin,
+	[KeyRelease] = keyrelease,
 	[KeyPress] = keypress,
 	[MappingNotify] = mappingnotify,
 	[MapRequest] = maprequest,
@@ -263,7 +281,7 @@ static void (*handler[LASTEvent]) (XEvent *) = {
 static Atom wmatom[WMLast], netatom[NetLast];
 static int running = 1;
 static Cur *cursor[CurLast];
-static Scm *scheme;
+static ClrScheme scheme[MAXCOLORS];
 static Display *dpy;
 static Drw *drw;
 static Monitor *mons, *selmon;
@@ -272,10 +290,82 @@ static Window root, wmcheckwin;
 /* configuration, allows nested code to access above variables */
 #include "config.h"
 
+struct Pertag {
+	unsigned int curtag, prevtag; /* current and previous tag */
+	int nmasters[LENGTH(tags) + 1]; /* number of windows in master area */
+	float mfacts[LENGTH(tags) + 1]; /* mfacts per tag */
+	float smfacts[LENGTH(tags) + 1]; /* smfacts per tag */
+	unsigned int sellts[LENGTH(tags) + 1]; /* selected layouts */
+	const Layout *ltidxs[LENGTH(tags) + 1][2]; /* matrix of tags and layouts indexes  */
+	Bool showbars[LENGTH(tags) + 1]; /* display bar for the current tag */
+	Client *prevzooms[LENGTH(tags) + 1]; /* store zoom information */
+};
+
 /* compile-time check if all tags fit into an unsigned int bit array. */
 struct NumTags { char limitexceeded[LENGTH(tags) > 31 ? -1 : 1]; };
 
 /* function implementations */
+static int combo = 0;
+
+void
+keyrelease(XEvent *e) {
+	combo = 0;
+}
+
+void
+combotag(const Arg *arg) {
+	if(selmon->sel && arg->ui & TAGMASK) {
+		if (combo) {
+			selmon->sel->tags |= arg->ui & TAGMASK;
+		} else {
+			combo = 1;
+			selmon->sel->tags = arg->ui & TAGMASK;
+		}
+		focus(NULL);
+		arrange(selmon);
+	}
+}
+
+void
+comboview(const Arg *arg) {
+	int i;
+	unsigned int tmptag;
+
+	unsigned newtags = arg->ui & TAGMASK;
+	if (combo) {
+		selmon->tagset[selmon->seltags] |= newtags;
+	} else {
+		selmon->seltags ^= 1;	/*toggle tagset*/
+		combo = 1;
+		if (arg->ui & TAGMASK) {
+			selmon->pertag->prevtag = selmon->pertag->curtag;
+			selmon->tagset[selmon->seltags] = arg->ui & TAGMASK;
+			if (arg->ui == ~0)
+				selmon->pertag->curtag = 0;
+			else {
+				for (i=0; !(arg->ui & 1 << i); i++) ;
+				selmon->pertag->curtag = i + 1;
+			}
+		} else {
+			tmptag = selmon->pertag->prevtag;
+			selmon->pertag->prevtag = selmon->pertag->curtag;
+			selmon->pertag->curtag = tmptag;
+		}
+		selmon->nmaster = selmon->pertag->nmasters[selmon->pertag->curtag];
+		selmon->mfact = selmon->pertag->mfacts[selmon->pertag->curtag];
+		selmon->smfact = selmon->pertag->smfacts[selmon->pertag->curtag];
+		selmon->sellt = selmon->pertag->sellts[selmon->pertag->curtag];
+		selmon->lt[selmon->sellt] = selmon->pertag->ltidxs[selmon->pertag->curtag][selmon->sellt];
+		selmon->lt[selmon->sellt^1] = selmon->pertag->ltidxs[selmon->pertag->curtag][selmon->sellt^1];
+		if (selmon->showbar != selmon->pertag->showbars[selmon->pertag->curtag])
+			togglebar(NULL);
+		if (newtags)
+			selmon->tagset[selmon->seltags] = newtags;
+	}
+	focus(NULL);
+	arrange(selmon);
+}
+
 void
 applyrules(Client *c)
 {
@@ -395,9 +485,24 @@ arrange(Monitor *m)
 void
 arrangemon(Monitor *m)
 {
+	int n = 0;
+	Client *c;
 	strncpy(m->ltsymbol, m->lt[m->sellt]->symbol, sizeof m->ltsymbol);
-	if (m->lt[m->sellt]->arrange)
-		m->lt[m->sellt]->arrange(m);
+	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++);
+	if ((m->lt[m->sellt]->arrange != monocle && n > 1) || !m->lt[m->sellt]->arrange) {
+		for (c = m->clients; c; c = c->next) {
+			if (ISVISIBLE(c) && (!m->lt[m->sellt]->arrange || !c->isfloating) && (c->bw != borderpx)) {
+				c->oldbw = c->bw;
+				c->bw = borderpx;
+				resizeclient(c, m->wx, m->wy, m->ww - (2 * c->bw), m->wh - (2 * c->bw));
+			}
+		}
+		if (m->lt[m->sellt]->arrange) {
+			m->lt[m->sellt]->arrange(m);
+		}
+	} else {
+		monocle(m);
+	}
 }
 
 void
@@ -456,6 +561,42 @@ buttonpress(XEvent *e)
 			buttons[i].func(click == ClkTagBar && buttons[i].arg.i == 0 ? &arg : &buttons[i].arg);
 }
 
+static void
+bstack(Monitor *m) {
+	int w, h, mh, mx, tx, ty, tw, smw;
+	unsigned int i, n;
+	Client *c;
+
+	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++);
+	if (n == 0)
+		return;
+	if (n > m->nmaster) {
+		mh = m->nmaster ? m->mfact * m->wh : 0;
+		tw = m->ww / (n - m->nmaster);
+		ty = m->wy + mh;
+	} else {
+		mh = m->wh;
+		tw = m->ww;
+		ty = m->wy;
+	}
+	for (i = mx = 0, tx = m->wx, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++) {
+		if (i < m->nmaster) {
+			w = (m->ww - mx) / (MIN(n, m->nmaster) - i);
+			resize(c, m->wx + mx, m->wy, w - (2 * c->bw), mh - (2 * c->bw), 0);
+			mx += WIDTH(c);
+		} else {
+			smw = m->ww * m->smfact;
+			h = m->wh - mh;
+			if(i == m->nmaster)
+				resize(c, tx, ty, tw + ((n - 1 - m->nmaster) * smw) - (2 * c->bw), h - (2 * c->bw), 0);
+			else
+				resize(c, tx, ty, tw - smw, h - (2 * c->bw), 0);
+			if (tw != m->ww)
+				tx += WIDTH(c);
+		}
+	}
+}
+
 void
 checkotherwm(void)
 {
@@ -485,9 +626,12 @@ cleanup(void)
 		cleanupmon(mons);
 	for (i = 0; i < CurLast; i++)
 		drw_cur_free(drw, cursor[i]);
-	for (i = 0; i < LENGTH(colors); i++)
-		free(scheme[i]);
-	XDestroyWindow(dpy, wmcheckwin);
+	for (i = 0; i < SchemeLast; i++) {
+		drw_clr_free(scheme[i].border);
+		drw_clr_free(scheme[i].bg);
+		drw_clr_free(scheme[i].fg);
+	}
++	XDestroyWindow(dpy, wmcheckwin);
 	drw_free(drw);
 	XSync(dpy, False);
 	XSetInputFocus(dpy, PointerRoot, RevertToPointerRoot, CurrentTime);
@@ -515,6 +659,7 @@ clientmessage(XEvent *e)
 {
 	XClientMessageEvent *cme = &e->xclient;
 	Client *c = wintoclient(cme->window);
+	int i;
 
 	if (!c)
 		return;
@@ -526,6 +671,8 @@ clientmessage(XEvent *e)
 	} else if (cme->message_type == netatom[NetActiveWindow]) {
 		if (c != selmon->sel && !c->isurgent)
 			seturgent(c, 1);
+		for(i=0; !(c->tags & 1 << i); i++);
+		view(&(Arg){.ui = 1 << i});
 	}
 }
 
@@ -632,16 +779,41 @@ Monitor *
 createmon(void)
 {
 	Monitor *m;
+	int i;
 
 	m = ecalloc(1, sizeof(Monitor));
 	m->tagset[0] = m->tagset[1] = 1;
 	m->mfact = mfact;
+	m->smfact = smfact;
 	m->nmaster = nmaster;
 	m->showbar = showbar;
 	m->topbar = topbar;
 	m->lt[0] = &layouts[0];
 	m->lt[1] = &layouts[1 % LENGTH(layouts)];
 	strncpy(m->ltsymbol, layouts[0].symbol, sizeof m->ltsymbol);
+	if (!(m->pertag = (Pertag *)calloc(1, sizeof(Pertag))))
+		die("fatal: could not malloc() %u bytes\n", sizeof(Pertag));
+	m->pertag->curtag = m->pertag->prevtag = 1;
+	for(i=0; i <= LENGTH(tags); i++) {
+		/* init nmaster */
+		m->pertag->nmasters[i] = m->nmaster;
+
+		/* init mfacts */
+		m->pertag->mfacts[i] = m->mfact;
+		/* init smfacts */
+		m->pertag->smfacts[i] = m->smfact;
+
+		/* init layouts */
+		m->pertag->ltidxs[i][0] = m->lt[0];
+		m->pertag->ltidxs[i][1] = m->lt[1];
+		m->pertag->sellts[i] = m->sellt;
+
+		/* init showbar */
+		m->pertag->showbars[i] = m->showbar;
+
+		/* swap focus and zoomswap*/
+		m->pertag->prevzooms[i] = NULL;
+	}
 	return m;
 }
 
@@ -696,18 +868,11 @@ dirtomon(int dir)
 void
 drawbar(Monitor *m)
 {
-	int x, w, sw = 0;
-	int boxs = drw->fonts->h / 9;
-	int boxw = drw->fonts->h / 6 + 2;
+	int x, xx, w, dx;
 	unsigned int i, occ = 0, urg = 0;
 	Client *c;
 
-	/* draw status first so it can be overdrawn by tags later */
-	if (m == selmon) { /* status is only drawn on selected monitor */
-		drw_setscheme(drw, scheme[SchemeNorm]);
-		sw = TEXTW(stext) - lrpad + 2; /* 2px right padding */
-		drw_text(drw, m->ww - sw, 0, sw, bh, 0, stext, 0);
-	}
+	dx = (drw->fonts[0]->ascent + drw->fonts[0]->descent + 2) / 4;
 
 	for (c = m->clients; c; c = c->next) {
 		occ |= c->tags;
@@ -717,27 +882,36 @@ drawbar(Monitor *m)
 	x = 0;
 	for (i = 0; i < LENGTH(tags); i++) {
 		w = TEXTW(tags[i]);
-		drw_setscheme(drw, scheme[m->tagset[m->seltags] & 1 << i ? SchemeSel : SchemeNorm]);
-		drw_text(drw, x, 0, w, bh, lrpad / 2, tags[i], urg & 1 << i);
-		if (occ & 1 << i)
-			drw_rect(drw, x + boxs, boxs, boxw, boxw,
-				m == selmon && selmon->sel && selmon->sel->tags & 1 << i,
-				urg & 1 << i);
+		drw_setscheme(drw, &scheme[(m->tagset[m->seltags] & 1 << i) ? 1 : (urg & 1 << i ? 2 : 0)]);
+		drw_text(drw, x, 0, w, bh, tags[i], 0);
+		drw_rect(drw, x + 1, 1, dx, dx, m == selmon && selmon->sel && selmon->sel->tags & 1 << i,
+		         occ & 1 << i, 0);
 		x += w;
 	}
 	w = blw = TEXTW(m->ltsymbol);
-	drw_setscheme(drw, scheme[SchemeNorm]);
-	x = drw_text(drw, x, 0, w, bh, lrpad / 2, m->ltsymbol, 0);
-
-	if ((w = m->ww - sw - x) > bh) {
+	drw_setscheme(drw, &scheme[0]);
+	drw_text(drw, x, 0, w, bh, m->ltsymbol, 0);
+	x += w;
+	xx = x;
+	if (m == selmon) { /* status is only drawn on selected monitor */
+		w = drw_get_width(drw, NUMCOLORS, stext);
+		x = m->ww - w;
+		if (x < xx) {
+			x = xx;
+			w = m->ww - xx;
+		}
+		drw_colored_text(drw, scheme, NUMCOLORS, x, 0, w, bh, stext);
+	} else
+		x = m->ww;
+	if ((w = x - xx) > bh) {
+		x = xx;
 		if (m->sel) {
-			drw_setscheme(drw, scheme[m == selmon ? SchemeSel : SchemeNorm]);
-			drw_text(drw, x, 0, w, bh, lrpad / 2, m->sel->name, 0);
-			if (m->sel->isfloating)
-				drw_rect(drw, x + boxs, boxs, boxw, boxw, m->sel->isfixed, 0);
+			drw_setscheme(drw, &scheme[m == selmon ? 1 : 0]);
+			drw_text(drw, x, 0, w, bh, m->sel->name, 0);
+			drw_rect(drw, x + 1, 1, dx, dx, m->sel->isfixed, m->sel->isfloating, 0);
 		} else {
-			drw_setscheme(drw, scheme[SchemeNorm]);
-			drw_rect(drw, x, 0, w, bh, 1, 1);
+			drw_setscheme(drw, &scheme[0]);
+			drw_rect(drw, x, 0, w, bh, 1, 0, 1);
 		}
 	}
 	drw_map(drw, m->barwin, 0, 0, m->ww, bh);
@@ -796,7 +970,7 @@ focus(Client *c)
 		detachstack(c);
 		attachstack(c);
 		grabbuttons(c, 1);
-		XSetWindowBorder(dpy, c->win, scheme[SchemeSel][ColBorder].pixel);
+		XSetWindowBorder(dpy, c->win, scheme[1].border->pix);
 		setfocus(c);
 	} else {
 		XSetInputFocus(dpy, root, RevertToPointerRoot, CurrentTime);
@@ -936,14 +1110,14 @@ grabbuttons(Client *c, int focused)
 		XUngrabButton(dpy, AnyButton, AnyModifier, c->win);
 		if (!focused)
 			XGrabButton(dpy, AnyButton, AnyModifier, c->win, False,
-				BUTTONMASK, GrabModeSync, GrabModeSync, None, None);
+			            BUTTONMASK, GrabModeSync, GrabModeSync, None, None);
 		for (i = 0; i < LENGTH(buttons); i++)
 			if (buttons[i].click == ClkClientWin)
 				for (j = 0; j < LENGTH(modifiers); j++)
 					XGrabButton(dpy, buttons[i].button,
-						buttons[i].mask | modifiers[j],
-						c->win, False, BUTTONMASK,
-						GrabModeAsync, GrabModeSync, None, None);
+					            buttons[i].mask | modifiers[j],
+					            c->win, False, BUTTONMASK,
+					            GrabModeAsync, GrabModeSync, None, None);
 	}
 }
 
@@ -961,14 +1135,14 @@ grabkeys(void)
 			if ((code = XKeysymToKeycode(dpy, keys[i].keysym)))
 				for (j = 0; j < LENGTH(modifiers); j++)
 					XGrabKey(dpy, code, keys[i].mod | modifiers[j], root,
-						True, GrabModeAsync, GrabModeAsync);
+					         True, GrabModeAsync, GrabModeAsync);
 	}
 }
 
 void
 incnmaster(const Arg *arg)
 {
-	selmon->nmaster = MAX(selmon->nmaster + arg->i, 0);
+	selmon->nmaster = selmon->pertag->nmasters[selmon->pertag->curtag] = MAX(selmon->nmaster + arg->i, 0);
 	arrange(selmon);
 }
 
@@ -1053,7 +1227,7 @@ manage(Window w, XWindowAttributes *wa)
 
 	wc.border_width = c->bw;
 	XConfigureWindow(dpy, w, CWBorderWidth, &wc);
-	XSetWindowBorder(dpy, w, scheme[SchemeNorm][ColBorder].pixel);
+	XSetWindowBorder(dpy, w, scheme[0].border->pix);
 	configure(c); /* propagates border_width, if size doesn't change */
 	updatewindowtype(c);
 	updatesizehints(c);
@@ -1111,10 +1285,19 @@ monocle(Monitor *m)
 	for (c = m->clients; c; c = c->next)
 		if (ISVISIBLE(c))
 			n++;
-	if (n > 0) /* override layout symbol */
+	if (n > 0 && m->lt[m->sellt]->arrange == monocle) /* override layout symbol */
 		snprintf(m->ltsymbol, sizeof m->ltsymbol, "[%d]", n);
-	for (c = nexttiled(m->clients); c; c = nexttiled(c->next))
-		resize(c, m->wx, m->wy, m->ww - 2 * c->bw, m->wh - 2 * c->bw, 0);
+	for(c = nexttiled(m->clients); c; c = nexttiled(c->next)) {
+		// I'm not sure, but calling resize with the border width subtractions
+		// fixes a glitch where windows would not redraw until they were
+		// manually resized after restarting dwm.
+		resize(c, m->wx, m->wy, m->ww - (2 * c->bw), m->wh - (2 * c->bw), False);
+		if (c->bw) {
+			c->oldbw = c->bw;
+			c->bw = 0;
+			resizeclient(c, m->wx, m->wy, m->ww, m->wh);
+		}
+	}
 }
 
 void
@@ -1151,7 +1334,7 @@ movemouse(const Arg *arg)
 	ocx = c->x;
 	ocy = c->y;
 	if (XGrabPointer(dpy, root, False, MOUSEMASK, GrabModeAsync, GrabModeAsync,
-		None, cursor[CurMove]->cursor, CurrentTime) != GrabSuccess)
+	    None, cursor[CurMove]->cursor, CurrentTime) != GrabSuccess)
 		return;
 	if (!getrootptr(&x, &y))
 		return;
@@ -1171,11 +1354,11 @@ movemouse(const Arg *arg)
 			nx = ocx + (ev.xmotion.x - x);
 			ny = ocy + (ev.xmotion.y - y);
 			if (abs(selmon->wx - nx) < snap)
-				nx = selmon->wx;
+				nx = selmon->wx + gappx;
 			else if (abs((selmon->wx + selmon->ww) - (nx + WIDTH(c))) < snap)
 				nx = selmon->wx + selmon->ww - WIDTH(c);
 			if (abs(selmon->wy - ny) < snap)
-				ny = selmon->wy;
+				ny = selmon->wy + gappx;
 			else if (abs((selmon->wy + selmon->wh) - (ny + HEIGHT(c))) < snap)
 				ny = selmon->wy + selmon->wh - HEIGHT(c);
 			if (!c->isfloating && selmon->lt[selmon->sellt]->arrange
@@ -1210,6 +1393,16 @@ pop(Client *c)
 	arrange(c->mon);
 }
 
+Client *
+prevtiled(Client *c) {
+	Client *p, *r;
+
+	for(p = selmon->clients, r = NULL; p && p != c; p = p->next)
+		if(!p->isfloating && ISVISIBLE(p))
+			r = p;
+	return r;
+}
+
 void
 propertynotify(XEvent *e)
 {
@@ -1247,6 +1440,37 @@ propertynotify(XEvent *e)
 	}
 }
 
+static void
+pushdown(const Arg *arg) {
+	Client *sel = selmon->sel, *c;
+
+	if(!sel || sel->isfloating || sel == nexttiled(selmon->clients))
+		return;
+	if((c = nexttiled(sel->next))) {
+		detach(sel);
+		sel->next = c->next;
+		c->next = sel;
+	}
+	focus(sel);
+	arrange(selmon);
+}
+
+static void
+pushup(const Arg *arg) {
+	Client *sel = selmon->sel, *c;
+
+	if(!sel || sel->isfloating)
+		return;
+	if((c = prevtiled(sel)) && c != nexttiled(selmon->clients)) {
+		detach(sel);
+		sel->next = c;
+		for(c = selmon->clients; c->next != sel->next; c = c->next);
+		c->next = sel;
+	}
+	focus(sel);
+	arrange(selmon);
+}
+
 void
 quit(const Arg *arg)
 {
@@ -1267,6 +1491,45 @@ recttomon(int x, int y, int w, int h)
 	return r;
 }
 
+static void
+recolor(const Arg *arg)
+{
+	size_t len = 0;
+	ssize_t nread;
+	char *line_buf = NULL;
+	FILE *fp = fopen("/home/cat/.Xresources", "r");
+	char norbg[8], norfg[8], selbg[8], selfg[8];
+
+	if (fp == NULL) {
+		fprintf(stderr, "failed to open Xresources\n");
+	}
+	while ((nread = getline(&line_buf, &len, fp)) != -1) {
+		if (norbg[0] != '#') {
+			sscanf(line_buf, "*." NORBG ": %7s", norbg);
+		} if (norfg[0] != '#') {
+			sscanf(line_buf, "*." NORFG ": %7s", norfg);
+		} if (selbg[0] != '#') {
+			sscanf(line_buf, "*." SELBG ": %7s", selbg);
+		} if (selfg[0] != '#') {
+			sscanf(line_buf, "*." SELFG ": %7s", selfg);
+		}
+	}
+	fclose(fp);
+
+	strcpy(colors[0][0], norbg);
+	strcpy(colors[0][1], norfg);
+	strcpy(colors[0][2], norbg);
+	strcpy(colors[1][0], selbg);
+	strcpy(colors[1][1], selfg);
+	strcpy(colors[1][2], selbg);
+
+	for (int i = 0; i < NUMCOLORS; i++) {
+		scheme[i].border = drw_clr_create(drw, colors[i][0]);
+		scheme[i].fg = drw_clr_create(drw, colors[i][1]);
+		scheme[i].bg = drw_clr_create(drw, colors[i][2]);
+	}
+}
+
 void
 resize(Client *c, int x, int y, int w, int h, int interact)
 {
@@ -1278,12 +1541,36 @@ void
 resizeclient(Client *c, int x, int y, int w, int h)
 {
 	XWindowChanges wc;
+	unsigned int n;
+	unsigned int gapoffset;
+	unsigned int gapincr;
+	Client *nbc;
 
-	c->oldx = c->x; c->x = wc.x = x;
-	c->oldy = c->y; c->y = wc.y = y;
-	c->oldw = c->w; c->w = wc.width = w;
-	c->oldh = c->h; c->h = wc.height = h;
 	wc.border_width = c->bw;
+
+	/* Get number of clients for the selected monitor */
+	for (n = 0, nbc = nexttiled(selmon->clients); nbc; nbc = nexttiled(nbc->next), n++);
+
+	/* Do nothing if layout is floating */
+	if (c->isfloating || selmon->lt[selmon->sellt]->arrange == NULL) {
+		gapincr = gapoffset = 0;
+	} else {
+		/* Remove border and gap if layout is monocle or only one client */
+		if (selmon->lt[selmon->sellt]->arrange == monocle || n == 1) {
+			gapoffset = 0;
+			gapincr = -2 * borderpx;
+			wc.border_width = 0;
+		} else {
+			gapoffset = gappx;
+			gapincr = 2 * gappx;
+		}
+	}
+
+	c->oldx = c->x; c->x = wc.x = x + gapoffset;
+	c->oldy = c->y; c->y = wc.y = y + gapoffset;
+	c->oldw = c->w; c->w = wc.width = w - gapincr;
+	c->oldh = c->h; c->h = wc.height = h - gapincr;
+
 	XConfigureWindow(dpy, c->win, CWX|CWY|CWWidth|CWHeight|CWBorderWidth, &wc);
 	configure(c);
 	XSync(dpy, False);
@@ -1293,9 +1580,14 @@ void
 resizemouse(const Arg *arg)
 {
 	int ocx, ocy, nw, nh;
+	int ocx2, ocy2, nx, ny;
 	Client *c;
 	Monitor *m;
 	XEvent ev;
+	int horizcorner, vertcorner;
+	int di;
+	unsigned int dui;
+	Window dummy;
 	Time lasttime = 0;
 
 	if (!(c = selmon->sel))
@@ -1305,10 +1597,19 @@ resizemouse(const Arg *arg)
 	restack(selmon);
 	ocx = c->x;
 	ocy = c->y;
+	ocx2 = c->x + c->w;
+	ocy2 = c->y + c->h;
 	if (XGrabPointer(dpy, root, False, MOUSEMASK, GrabModeAsync, GrabModeAsync,
 		None, cursor[CurResize]->cursor, CurrentTime) != GrabSuccess)
 		return;
-	XWarpPointer(dpy, None, c->win, 0, 0, 0, 0, c->w + c->bw - 1, c->h + c->bw - 1);
+	if (!XQueryPointer (dpy, c->win, &dummy, &dummy, &di, &di, &nx, &ny, &dui))
+	       return;
+	horizcorner = nx < c->w / 2;
+	vertcorner = ny < c->h / 2;
+	XWarpPointer (dpy, None, c->win, 0, 0, 0, 0,
+		      horizcorner ? (-c->bw) : (c->w + c->bw - 1),
+		      vertcorner ? (-c->bw) : (c->h + c->bw - 1));
+
 	do {
 		XMaskEvent(dpy, MOUSEMASK|ExposureMask|SubstructureRedirectMask, &ev);
 		switch(ev.type) {
@@ -1324,6 +1625,11 @@ resizemouse(const Arg *arg)
 
 			nw = MAX(ev.xmotion.x - ocx - 2 * c->bw + 1, 1);
 			nh = MAX(ev.xmotion.y - ocy - 2 * c->bw + 1, 1);
+			nx = horizcorner ? ev.xmotion.x : c->x;
+			ny = vertcorner ? ev.xmotion.y : c->y;
+			nw = MAX(horizcorner ? (ocx2 - nx) : (ev.xmotion.x - ocx - 2 * c->bw + 1), 1);
+			nh = MAX(vertcorner ? (ocy2 - ny) : (ev.xmotion.y - ocy - 2 * c->bw + 1), 1);
+
 			if (c->mon->wx + nw >= selmon->wx && c->mon->wx + nw <= selmon->wx + selmon->ww
 			&& c->mon->wy + nh >= selmon->wy && c->mon->wy + nh <= selmon->wy + selmon->wh)
 			{
@@ -1332,11 +1638,13 @@ resizemouse(const Arg *arg)
 					togglefloating(NULL);
 			}
 			if (!selmon->lt[selmon->sellt]->arrange || c->isfloating)
-				resize(c, c->x, c->y, nw, nh, 1);
+				resize(c, nx, ny, nw, nh, 1);
 			break;
 		}
 	} while (ev.type != ButtonRelease);
-	XWarpPointer(dpy, None, c->win, 0, 0, 0, 0, c->w + c->bw - 1, c->h + c->bw - 1);
+	XWarpPointer(dpy, None, c->win, 0, 0, 0, 0,
+		      horizcorner ? (-c->bw) : (c->w + c->bw - 1),
+		      vertcorner ? (-c->bw) : (c->h + c->bw - 1));
 	XUngrabPointer(dpy, CurrentTime);
 	while (XCheckMaskEvent(dpy, EnterWindowMask, &ev));
 	if ((m = recttomon(c->x, c->y, c->w, c->h)) != selmon) {
@@ -1431,7 +1739,7 @@ setclientstate(Client *c, long state)
 	long data[] = { state, None };
 
 	XChangeProperty(dpy, c->win, wmatom[WMState], wmatom[WMState], 32,
-		PropModeReplace, (unsigned char *)data, 2);
+	                PropModeReplace, (unsigned char *)data, 2);
 }
 
 int
@@ -1502,10 +1810,13 @@ setfullscreen(Client *c, int fullscreen)
 void
 setlayout(const Arg *arg)
 {
-	if (!arg || !arg->v || arg->v != selmon->lt[selmon->sellt])
-		selmon->sellt ^= 1;
+	if (!arg || !arg->v || arg->v != selmon->lt[selmon->sellt]) {
+		selmon->pertag->sellts[selmon->pertag->curtag] ^= 1;
+		selmon->sellt = selmon->pertag->sellts[selmon->pertag->curtag];
+	}
 	if (arg && arg->v)
-		selmon->lt[selmon->sellt] = (Layout *)arg->v;
+		selmon->pertag->ltidxs[selmon->pertag->curtag][selmon->sellt] = (Layout *)arg->v;
+	selmon->lt[selmon->sellt] = selmon->pertag->ltidxs[selmon->pertag->curtag][selmon->sellt];
 	strncpy(selmon->ltsymbol, selmon->lt[selmon->sellt]->symbol, sizeof selmon->ltsymbol);
 	if (selmon->sel)
 		arrange(selmon);
@@ -1524,14 +1835,26 @@ setmfact(const Arg *arg)
 	f = arg->f < 1.0 ? arg->f + selmon->mfact : arg->f - 1.0;
 	if (f < 0.1 || f > 0.9)
 		return;
-	selmon->mfact = f;
+	selmon->mfact = selmon->pertag->mfacts[selmon->pertag->curtag] = f;
+	arrange(selmon);
+}
+
+void
+setsmfact(const Arg *arg) {
+	float sf;
+
+	if(!arg || !selmon->lt[selmon->sellt]->arrange)
+		return;
+	sf = arg->sf < 1.0 ? arg->sf + selmon->smfact : arg->sf - 1.0;
+	if(sf < 0 || sf > 0.9)
+		return;
+	selmon->smfact = selmon->pertag->smfacts[selmon->pertag->curtag] = sf;
 	arrange(selmon);
 }
 
 void
 setup(void)
 {
-	int i;
 	XSetWindowAttributes wa;
 	Atom utf8string;
 
@@ -1544,10 +1867,10 @@ setup(void)
 	sh = DisplayHeight(dpy, screen);
 	root = RootWindow(dpy, screen);
 	drw = drw_create(dpy, screen, root, sw, sh);
-	if (!drw_fontset_create(drw, fonts, LENGTH(fonts)))
+	drw_load_fonts(drw, fonts, LENGTH(fonts));
+	if (!drw->fontcount)
 		die("no fonts could be loaded.");
-	lrpad = drw->fonts->h;
-	bh = drw->fonts->h + 2;
+	bh = drw->fonts[0]->h + 2;
 	updategeom();
 	/* init atoms */
 	utf8string = XInternAtom(dpy, "UTF8_STRING", False);
@@ -1569,36 +1892,33 @@ setup(void)
 	cursor[CurResize] = drw_cur_create(drw, XC_sizing);
 	cursor[CurMove] = drw_cur_create(drw, XC_fleur);
 	/* init appearance */
-	scheme = ecalloc(LENGTH(colors), sizeof(Scm));
-	for (i = 0; i < LENGTH(colors); i++)
-		scheme[i] = drw_scm_create(drw, colors[i], 3);
+	recolor(NULL);
 	/* init bars */
 	updatebars();
 	updatestatus();
 	/* supporting window for NetWMCheck */
 	wmcheckwin = XCreateSimpleWindow(dpy, root, 0, 0, 1, 1, 0, 0, 0);
 	XChangeProperty(dpy, wmcheckwin, netatom[NetWMCheck], XA_WINDOW, 32,
-		PropModeReplace, (unsigned char *) &wmcheckwin, 1);
+	                PropModeReplace, (unsigned char *) &wmcheckwin, 1);
 	XChangeProperty(dpy, wmcheckwin, netatom[NetWMName], utf8string, 8,
-		PropModeReplace, (unsigned char *) "dwm", 4);
+	                PropModeReplace, (unsigned char *) "dwm", 4);
 	XChangeProperty(dpy, root, netatom[NetWMCheck], XA_WINDOW, 32,
-		PropModeReplace, (unsigned char *) &wmcheckwin, 1);
+	                PropModeReplace, (unsigned char *) &wmcheckwin, 1);
 	/* EWMH support per view */
 	XChangeProperty(dpy, root, netatom[NetSupported], XA_ATOM, 32,
-		PropModeReplace, (unsigned char *) netatom, NetLast);
+	                PropModeReplace, (unsigned char *) netatom, NetLast);
 	XDeleteProperty(dpy, root, netatom[NetClientList]);
 	/* select events */
 	wa.cursor = cursor[CurNormal]->cursor;
 	wa.event_mask = SubstructureRedirectMask|SubstructureNotifyMask
-		|ButtonPressMask|PointerMotionMask|EnterWindowMask
-		|LeaveWindowMask|StructureNotifyMask|PropertyChangeMask;
+	                |ButtonPressMask|PointerMotionMask|EnterWindowMask
+	                |LeaveWindowMask|StructureNotifyMask|PropertyChangeMask;
 	XChangeWindowAttributes(dpy, root, CWEventMask|CWCursor, &wa);
 	XSelectInput(dpy, root, wa.event_mask);
 	grabkeys();
 	focus(NULL);
 }
 
-
 void
 seturgent(Client *c, int urg)
 {
@@ -1675,7 +1995,7 @@ tagmon(const Arg *arg)
 void
 tile(Monitor *m)
 {
-	unsigned int i, n, h, mw, my, ty;
+	unsigned int i, n, h, smh, mw, my, ty;
 	Client *c;
 
 	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++);
@@ -1692,16 +2012,30 @@ tile(Monitor *m)
 			resize(c, m->wx, m->wy + my, mw - (2*c->bw), h - (2*c->bw), 0);
 			my += HEIGHT(c);
 		} else {
-			h = (m->wh - ty) / (n - i);
-			resize(c, m->wx + mw, m->wy + ty, m->ww - mw - (2*c->bw), h - (2*c->bw), 0);
-			ty += HEIGHT(c);
+			smh = m->mh * m->smfact;
+			if(!(nexttiled(c->next)))
+				h = (m->wh - ty) / (n - i);
+			else
+				h = (m->wh - smh - ty) / (n - i);
+			if(h < minwsz) {
+				c->isfloating = True;
+				XRaiseWindow(dpy, c->win);
+				resize(c, m->mx + (m->mw / 2 - WIDTH(c) / 2), m->my + (m->mh / 2 - HEIGHT(c) / 2), m->ww - mw - (2*c->bw), h - (2*c->bw), False);
+				ty -= HEIGHT(c);
+			}
+			else
+				resize(c, m->wx + mw, m->wy + ty, m->ww - mw - (2*c->bw), h - (2*c->bw), False);
+			if(!(nexttiled(c->next)))
+				ty += HEIGHT(c) + smh;
+			else
+				ty += HEIGHT(c);
 		}
 }
 
 void
 togglebar(const Arg *arg)
 {
-	selmon->showbar = !selmon->showbar;
+	selmon->showbar = selmon->pertag->showbars[selmon->pertag->curtag] = !selmon->showbar;
 	updatebarpos(selmon);
 	XMoveResizeWindow(dpy, selmon->barwin, selmon->wx, selmon->by, selmon->ww, bh);
 	arrange(selmon);
@@ -1715,9 +2049,14 @@ togglefloating(const Arg *arg)
 	if (selmon->sel->isfullscreen) /* no support for fullscreen windows */
 		return;
 	selmon->sel->isfloating = !selmon->sel->isfloating || selmon->sel->isfixed;
-	if (selmon->sel->isfloating)
+	if (selmon->sel->isfloating) {
+		if (selmon->sel->bw != borderpx) {
+			selmon->sel->oldbw = selmon->sel->bw;
+			selmon->sel->bw = borderpx;
+		}
 		resize(selmon->sel, selmon->sel->x, selmon->sel->y,
-			selmon->sel->w, selmon->sel->h, 0);
+		       selmon->sel->w - selmon->sel->bw * 2, selmon->sel->h - selmon->sel->bw * 2, 0);
+	}
 	arrange(selmon);
 }
 
@@ -1740,9 +2079,29 @@ void
 toggleview(const Arg *arg)
 {
 	unsigned int newtagset = selmon->tagset[selmon->seltags] ^ (arg->ui & TAGMASK);
+	int i;
 
 	if (newtagset) {
+		if (newtagset == ~0) {
+			selmon->pertag->prevtag = selmon->pertag->curtag;
+			selmon->pertag->curtag = 0;
+		}
+		/* test if the user did not select the same tag */
+		if (!(newtagset & 1 << (selmon->pertag->curtag - 1))) {
+			selmon->pertag->prevtag = selmon->pertag->curtag;
+			for (i=0; !(newtagset & 1 << i); i++) ;
+			selmon->pertag->curtag = i + 1;
+		}
 		selmon->tagset[selmon->seltags] = newtagset;
+
+		/* apply settings for this view */
+		selmon->nmaster = selmon->pertag->nmasters[selmon->pertag->curtag];
+		selmon->mfact = selmon->pertag->mfacts[selmon->pertag->curtag];
+		selmon->sellt = selmon->pertag->sellts[selmon->pertag->curtag];
+		selmon->lt[selmon->sellt] = selmon->pertag->ltidxs[selmon->pertag->curtag][selmon->sellt];
+		selmon->lt[selmon->sellt^1] = selmon->pertag->ltidxs[selmon->pertag->curtag][selmon->sellt^1];
+		if (selmon->showbar != selmon->pertag->showbars[selmon->pertag->curtag])
+			togglebar(NULL);
 		focus(NULL);
 		arrange(selmon);
 	}
@@ -1754,7 +2113,7 @@ unfocus(Client *c, int setfocus)
 	if (!c)
 		return;
 	grabbuttons(c, 0);
-	XSetWindowBorder(dpy, c->win, scheme[SchemeNorm][ColBorder].pixel);
+	XSetWindowBorder(dpy, c->win, scheme[0].border->pix);
 	if (setfocus) {
 		XSetInputFocus(dpy, root, RevertToPointerRoot, CurrentTime);
 		XDeleteProperty(dpy, root, netatom[NetActiveWindow]);
@@ -1982,7 +2341,7 @@ updatesizehints(Client *c)
 	} else
 		c->maxa = c->mina = 0.0;
 	c->isfixed = (c->maxw && c->minw && c->maxh && c->minh
-		&& c->maxw == c->minw && c->maxh == c->minh);
+	              && c->maxw == c->minw && c->maxh == c->minh);
 }
 
 void
@@ -2036,11 +2395,33 @@ updatewmhints(Client *c)
 void
 view(const Arg *arg)
 {
+	int i;
+	unsigned int tmptag;
+
 	if ((arg->ui & TAGMASK) == selmon->tagset[selmon->seltags])
 		return;
 	selmon->seltags ^= 1; /* toggle sel tagset */
-	if (arg->ui & TAGMASK)
+	if (arg->ui & TAGMASK) {
+		selmon->pertag->prevtag = selmon->pertag->curtag;
 		selmon->tagset[selmon->seltags] = arg->ui & TAGMASK;
+		if (arg->ui == ~0)
+			selmon->pertag->curtag = 0;
+		else {
+			for (i=0; !(arg->ui & 1 << i); i++) ;
+			selmon->pertag->curtag = i + 1;
+		}
+	} else {
+		tmptag = selmon->pertag->prevtag;
+		selmon->pertag->prevtag = selmon->pertag->curtag;
+		selmon->pertag->curtag = tmptag;
+	}
+	selmon->nmaster = selmon->pertag->nmasters[selmon->pertag->curtag];
+	selmon->mfact = selmon->pertag->mfacts[selmon->pertag->curtag];
+	selmon->sellt = selmon->pertag->sellts[selmon->pertag->curtag];
+	selmon->lt[selmon->sellt] = selmon->pertag->ltidxs[selmon->pertag->curtag][selmon->sellt];
+	selmon->lt[selmon->sellt^1] = selmon->pertag->ltidxs[selmon->pertag->curtag][selmon->sellt^1];
+	if (selmon->showbar != selmon->pertag->showbars[selmon->pertag->curtag])
+		togglebar(NULL);
 	focus(NULL);
 	arrange(selmon);
 }
@@ -2092,7 +2473,7 @@ xerror(Display *dpy, XErrorEvent *ee)
 	|| (ee->request_code == X_CopyArea && ee->error_code == BadDrawable))
 		return 0;
 	fprintf(stderr, "dwm: fatal error: request code=%d, error code=%d\n",
-		ee->request_code, ee->error_code);
+	        ee->request_code, ee->error_code);
 	return xerrorxlib(dpy, ee); /* may call exit */
 }
 
diff --git a/./dwm.o b/../dwm-p/dwm.o
index 4347fde..c7edd4e 100644
Binary files a/./dwm.o and b/../dwm-p/dwm.o differ
diff --git a/./util.h b/../dwm-p/util.h
index f633b51..cded043 100644
--- a/./util.h
+++ b/../dwm-p/util.h
@@ -4,5 +4,5 @@
 #define MIN(A, B)               ((A) < (B) ? (A) : (B))
 #define BETWEEN(X, A, B)        ((A) <= (X) && (X) <= (B))
 
-void die(const char *fmt, ...);
-void *ecalloc(size_t nmemb, size_t size);
+void die(const char *errstr, ...);
+void *ecalloc(size_t, size_t);
